# -*- coding: utf-8 -*-
"""assignment2pw.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RnioJFjzMA-DWdzj3XyPjNOInDusA1yc
"""



"""Q1.What are data structures, and why are they important?
- Data structures are ways of organizing and storing data in a computer so that it can be accessed and modified efficiently.
- Why They’re Important:
  - Efficiency: The right data structure makes your code faster and more efficient.
  - Problem Solving: Many real-world problems can be mapped to data structures.
  - Scalability: Helps in handling large amounts of data smoothly.

Q2. Explain the difference between mutable and immutable data types with examples.
- Mutable Data Types : These can be changed after they’re created. You can modify, add, or remove elements without creating a new object.
- Examples:
  - Lists
  - Dictionaries
  - Set
- Immutable Data Types : These cannot be changed after creation. If you want to modify them, you end up creating a new object.
- Examples:
  - Integers
  - Floats
  - Strings
  - Tuples

Q3. What are the main differences between lists and tuples in Python?
- Feature..................List ([])..............................Tuple (())
 - Mutability...............Mutable................................Immutable
 - Syntax...................[1, 2, 3]..............................(1, 2, 3)
 - Can change elements?.....Yes....................................No
 - Methods available........More(append,remove)........Fewer(e.g., count, index)
 - Speed....................Slower (more flexible)........Faster (less overhead)
 - Use case............When data might change......When data should stay constant
 - Can be dictionary key?....No...............Yes (if all elements are immutable)

Q4.Describe how dictionaries store data.
- A dictionary is a built-in Python data structure that stores key-value pairs.
- How Data Is Stored Internally :
  - Python dictionaries are implemented using a hash table. Here's how it works:
  - Hashing the Key:When you use a key, Python runs it through a hash function to turn it into a unique number (called a hash).
  - Finding the Bucket:The hash value determines where in memory (which "bucket") to store the value.
  - Storing the Pair:The key and value are stored together in that spot.
  - Retrieving Data:When you look up a key, Python hashes it again and jumps straight to the correct memory location — super fast!

Q5. Why might you use a set instead of a list in Python?
1. You Need Only Unique Items
 - names = ["Alice", "Bob", "Alice", "Charlie"]
 - unique_names = set(names)
 - print(unique_names)  # {'Alice', 'Bob', 'Charlie'}
2. Faster Membership Tests
 - Checking if something is in a set is much faster than in a list.
 - Code:
    - x in some_set  #  O(1) average time
    - x in some_list #  O(n) time
    - This matters a lot when you have a big dataset.
3. You Want Set Operations
 - Sets support powerful math-like operations:
 - Code :
    - a = {1, 2, 3}
    - b = {3, 4, 5}
    - print(a & b)  # Intersection → {3}
    - print(a | b)  # Union → {1, 2, 3, 4, 5}
    - print(a - b)  # Difference → {1, 2}  

Q6. What is a string in Python, and how is it different from a list.
- A string is a sequence of characters, used to represent text.
- Code :
     - message = "hello world" (Each character in a string has an index (message[0] == 'h'))
- Strings are immutable  you can't change them after creation
- They're typically used to store textual data
- Difference from List :
- Feature..............................String..............................List
  - Type of elements...........Characters (text)......Any type (int, str, bool…)
  - Mutability.....................Immutable............................Mutable
  - Syntax........................"hello"..............['h', 'e', 'l', 'l', 'o']
  - Methods........String-specific(.upper(),.split())..List-specific(.append(), .pop())
  - Usage....................Text processing.........General-purpose collections

Q7. How do tuples ensure data integrity in Python?
- Data integrity means keeping data accurate, consistent, and unchanged unless intentionally modified.
- How Tuples Help Ensure That:
1. Immutability :
- Tuples are immutable, meaning once you create them, you can’t change them.
  You can't add, remove, or change elements.
- Code :   
user_info = ("Alice", 21)
(#user_info[0] = "Bob" This will raise an error)
- This protects the data from accidental modification during program execution.
2. Predictable and Reliable :
- Since the data in a tuple doesn’t change, it’s safe to:
   - Use as dictionary keys
   - Pass between functions without worry of accidental update
   - Store fixed configurations or constants
- Code :
config = ("localhost", 8080)  # Safe and fixed
3. Hashable :
- Because tuples are immutable, they're hashable (if all their elements are also immutable).
This allows them to be used in sets and as dictionary keys, which require stable, unchanging values.
- Code :
   - user = ("Alice", "Admin")
   - permissions = {user: ["read", "write"]}

Q8. What is a hash table, and how does it relate to dictionaries in Python?
- A hash table is a data structure that stores key-value pairs and allows for fast data retrieval using a hash function.
-  How Does This Relate to Dictionaries in Python? :
    - In Python, dictionaries are built on top of hash tables.
    - Code :
            - fruit_colors = {
                    - "apple": "red",
                    - "banana": "yellow"
            - }
            - [ "apple" is hashed
            - Its hash determines where "red" is stored
            - Looking up fruit_colors["apple"] is super fast (average time: O(1)) ]


Q9.Can lists contain different data types in Python.
- Yes — lists in Python can contain different data types!
That’s one of the cool things about Python: it’s dynamically typed, so a list can hold a mix of strings, numbers, booleans, even other lists or custom objects.
- Example:
    - my_list = [42, "hello", 3.14, True, [1, 2, 3]]
    - print(my_list)
        - Output:[42, 'hello', 3.14, True, [1, 2, 3]]


Q10. Explain why strings are immutable in Python.
-  Why Are Strings Immutable?
1. Efficiency & Performance : Python reuses string objects when possible (a process called string interning).
This makes string handling faster and more memory-efficient, but it only works if the strings are guaranteed not to change.
- Code :
    - a = "hello"
    - b = "hello"
    - print(a is b)  # True (same memory location)
2. Safety : Strings are used as keys in dictionaries and elements in sets, which require hashable (unchanging) values.
If strings were mutable, their hash value could change — breaking these data structures.
- Code :
    - my_dict = {"hello": 5}  # works fine because "hello" can't change
3. Predictable Behavior : You never have to worry that passing a string into a function will accidentally modify the original value.
- Code :
    - def shout(word):
          - word = word.upper()
          - return word
    - text = "hi"
    - shout(text)  # "HI"
    - print(text)  # still "hi"
4. Thread-Safe : Since strings can’t change, they are naturally safe to use across threads without needing locks or extra protection.

Q11.What advantages do dictionaries offer over lists for certain tasks?
- Advantages of Dictionaries Over Lists
1. Fast Lookups (O(1) Average Time) :
  - Dictionaries provide constant-time access to values via keys, making them much faster for lookups compared to lists.With lists, you often have to search through the entire list to find an item, which takes O(n) time (linear search).
  - Example :
      - (# List Lookup (O(n) time complexity))
      - my_list = [10, 20, 30, 40]
      - print(30 in my_list)  # This will scan the entire list
      - [# Dictionary Lookup (O(1) time complexity)]
      - my_dict = {1: "apple", 2: "banana", 3: "cherry"}
      - print(2 in my_dict)  # Instant, no scan needed!
2. Key-Value Pair Storage (Associative Data) :
   - Dictionaries are built to store key-value pairs, making them ideal for tasks where you want to associate values with unique identifiers.In contrast, lists only store a sequence of values, and you often need to manually track what each value represents.
   - Example: Storing user info in a list would be cumbersome :
       - user_list = ["Alice", 25, "New York"]
       - But with a dictionary, it's clear:
            - user_dict = {"name": "Alice", "age": 25, "city": "New York"}
3. Uniqueness of Keys :
   - Dictionaries enforce uniqueness of keys automatically, meaning you cannot  have two identical keys.With lists, there is no automatic enforcement of uniqueness; duplicate values can easily sneak in.
   - Example:
        - [# Dictionary automatically handles uniqueness]
        - my_dict = {"a": 1, "b": 2, "c": 3}
        - my_dict["a"] = 4  # Replaces "a": 1 with "a": 4
        - [# List can have duplicates]
        - my_list = [1, 1, 2, 3]
4. Better Organization for Large Datasets :
   - When working with large datasets where you need to access values based on specific attributes (keys), dictionaries are much more efficient and easy to manage compared to lists.Lists might require iterating over all elements to find something, whereas dictionaries allow you to jump straight to the value using the key.
   - Example: Imagine managing a phonebook where the key is a person's name and the value is their phone number:
         - phonebook = {"Alice": "555-1234", "Bob": "555-5678"}
         - [#Searching by name in a dictionary is instant — no need to search through the entire list.]
5. Support for Complex Data Structures
   - You can store complex data structures in dictionaries, such as lists, tuples, or other dictionaries, creating hierarchical or nested data.Lists are limited in this sense because they don't provide a natural way to associate one piece of data with another.
   - Example:
        - [# Nested dictionary (stores multiple phone numbers for a user)]
        - contacts = {
              - "Alice": {"home": "555-1234", "work": "555-4321"},
              - "Bob": {"home": "555-5678", "work": "555-8765"}
        - }


Q12Describe a scenario where using a tuple would be preferable over a list.
- Scenario : Representing Coordinates
   - Let’s say you're building a program that deals with geometry or mapping — like a game or a GPS system.
   - You want to store a point in 2D space, like (x, y).
       - point = (5, 10)  # tuple
   - (This is a perfect place to use a tuple instead of a list.)
   - Why a Tuple Is Better Here:
       - Reason	Why It Matters
         - Fixed size	Coordinates always have 2 values (x, y) — it won’t change
         - Immutable	Prevents accidental changes to the coordinates
         - More semantic clarity	Tuples are great for grouping related but distinct values
        - Faster and memory-efficient	Tuples are lighter than lists
- Real-World Use Cases Where Tuples Are Preferable:
      - Function returns with multiple values:
            - def get_size():
                  - return (width, height)  # Tuple is clear and fixed-size
       - Dictionary keys:
            - location_map = {
                  - (40.7128, -74.0060): "New York",
                  - (34.0522, -118.2437): "Los Angeles"
             - }
        - Data integrity : Use a tuple when you want to guarantee the data won’t be modified accidentally.

Q13. How do sets handle duplicate values in Python?
- How Sets Handle Duplicate Values:
    - In Python, a set is an unordered collection of unique elements.That means if you try to add duplicates, the set will silently ignore them.
- Example:
    - my_set = {1, 2, 2, 3, 4, 4, 4}
    - print(my_set)  # ➜ {1, 2, 3, 4}
    - [Even though 2 and 4 appear multiple times in the code, the set only keeps one copy of each value.]

Q14. How does the “in” keyword work differently for lists and dictionaries?
- in with Lists :
     - When used with a list, in checks if a value is present anywhere in the list.
     - Example:
          - my_list = [1, 2, 3, 4]
          - print(3 in my_list)     # ➜ True
          - print(5 in my_list)     # ➜ False
    - Python iterates through the list (linear search), so it's O(n) time complexity.
- in with Dictionaries :
     - When used with a dictionary, in checks if a key is present — not the value.
     - Example :
          - my_dict = {"apple": 1, "banana": 2}
          - print("apple" in my_dict)    # ➜ True  (checks keys)
          - print(1 in my_dict)          # ➜ False (not checking values!)
    - If you want to check for a value in a dictionary :
          - print(1 in my_dict.values())       # ➜ True
          - print("banana" in my_dict.keys())  # ➜ True
     - Dict lookups are O(1) on average because they're backed by a hash table.

Q15. Can you modify the elements of a tuple? Explain why or why not.
- Tuples Are Immutable : That means once a tuple is created, you can’t change, add, or remove elements.
- Example:
     - my_tuple = (1, 2, 3)
     - my_tuple[0] = 10  #This will raise a TypeError
          - Output:
                 - TypeError: 'tuple' object does not support item assignment
- Why Tuples Are Immutable :
    - Data integrity: Good for storing fixed collections of values (like coordinates, RGB colors, database records).
    - Hashability: Only immutable types can be hashable (and used as dictionary keys or set elements).
    - Safety: Prevents accidental changes in large programs or when passing tuples between functions.
- Can a Tuple Contain Mutable Elements?
    - Yes! The tuple itself is immutable, but it can hold mutable elements, like lists:
    - my_tuple = (1, [2, 3], 4)
    - my_tuple[1][0] = 99
    - print(my_tuple)  # ➜ (1, [99, 3], 4)
           - In this case:
                 - The tuple’s structure didn’t change (still 3 elements),But the list inside the tuple was modified — because the list itself is mutable.


Q16. What is a nested dictionary, and give an example of its use case?
- A nested dictionary in Python is simply a dictionary within another dictionary. It's a way to organize hierarchical or multi-level data — kind of like a tree structure or a JSON object.
- What Is a Nested Dictionary?
    - A nested dictionary looks like this:
         - nested_dict = {
               - "person1": {"name": "Alice", "age": 25},
               - "person2": {"name": "Bob", "age": 30}
         - }
    - Here, each value inside the outer dictionary is another dictionary.
- Why Use a Nested Dictionary?
    - They’re super useful when you want to model structured data, such as:
          - JSON-like objects
          - Database records
          - Grouped attributes (like settings or profiles)
          - Multi-level categorization
- Example Use Case: Student Records
    - Let’s say you’re building a system to store students’ grades by subject:
          - students = {
                - "alice": {
                     - "math": 90,
                     - "english": 85
                - },
                - "bob": {
                      - "math": 78,
                      - "english": 88
                - }
          - }
- Accessing data is easy:
   - print(students["alice"]["math"])  # ➜ 90
- Another Use Case: Settings/Configuration
   - config = {
         - "theme": {
              - "background": "dark",
              - "font_size": 14
         - },
         - "user": {
              - "username": "admin",
              - "email": "admin@example.com"
        - }
    - }

Q17. Describe the time complexity of accessing elements in a dictionary.
- Time Complexity of Accessing Elements in a Dictionary
    - Average Case:O(1) — Constant time
        - Python dictionaries use a hash table under the hood.
        - When you access an element by key (e.g., my_dict["apple"]), Python:
Computes the hash of the key
        - Jumps directly to the memory location associated with that hash
        - This allows for super-fast, direct access.
    - Worst Case: O(n) — Linear time
        - This only happens rarely, due to hash collisions (when multiple keys hash to the same slot).
        - Python handles collisions gracefully with open addressing, but if too many occur, performance can degrade.
- Example:
     - my_dict = {"a": 1, "b": 2, "c": 3}
     - print(my_dict["b"])  # O(1) access

Q18. In what situations are lists preferred over dictionaries.
- When to Prefer Lists Over Dictionaries
1. Order Matters : Lists maintain insertion order, and sometimes sequence matters (e.g., step-by-step instructions, task queues, or time-based data).
   - tasks = ["wake up", "eat", "study", "sleep"]
2. No Key-Value Relationship Needed : If you're just storing a bunch of values (like numbers or names), a list is simpler and easier to work with.
   - names = ["Alice", "Bob", "Charlie"]
3. Duplicates Are Okay or Required :  Lists allow duplicates, while dictionaries require unique keys
   - scores = [85, 92, 85, 78]  # Repeated score is fine
4. Index-Based Access : If you want to access or manipulate items by their position/index, lists are ideal.
   - shopping = ["milk", "eggs", "bread"]
   - print(shopping[1])  # ➜ "eggs"
5. You Want to Sort the Data : Lists are much easier to sort and filter.
   - numbers = [5, 2, 9, 1]
   - numbers.sort()
   - print(numbers)  # ➜ [1, 2, 5, 9]
6. Lightweight Data Storage : Lists are more memory-efficient when you don’t need the complexity of keys.

Q19. Why are dictionaries considered unordered, and how does that affect data retrieval?
- Why Are Dictionaries Considered Unordered? :
     - Historically, dictionaries in Python were considered unordered collections — meaning the order in which you added key-value pairs wasn’t guaranteed to be maintained.
- This changed in Python 3.7+ : Now, dictionaries do preserve insertion order, but they are still not meant for ordered operations like lists are.So while the order is predictable, it shouldn’t be relied on for things like sorting or indexing unless you’re doing it intentionally.
- So What Does That Mean for Data Retrieval? :
    - Data retrieval by key is still super fast:
         - person = {"name": "Alice", "age": 25, "city": "London"}
         - print(person["age"])  # ➜ 25
- This works fine because dictionaries use keys to access values — not position or order.
- But you can’t do this:
     - print(person[1])  # TypeError: can't access by index
     - Unlike lists, you can’t access values by numeric index like dict[0].

Q20. Explain the difference between a list and a dictionary in terms of data retrieval.
- Main Difference in Retrieval :
    - Feature....................List..............................Dictionary
         - Access by..........Index (position)..........Key (label/identifier)
         - Lookup type......Sequential / indexed...........Key-based / mapped
         - Speed..........Slower (O(n) for searching)......Faster (O(1) average lookup time)
- Example usage	Ordered collections like a to-do list	Structured data like user profiles
- Example: List
       - fruits = ["apple", "banana", "cherry"]
       - print(fruits[1])  # ➜ "banana" (accessed by index)
       -[Here, you retrieve the item based on its position in the list.]
- Example: Dictionary
       - person = {"name": "Alice", "age": 25, "city": "Paris"}
       - print(person["age"])  # ➜ 25 (accessed by key)
       - [Here, you retrieve the value based on the key — not where it is in the dictionary.]


"""

# PRACTICAL QUESTIONS
#Q1. Write a code to create a string with your name and print it
name = "POOJA DESHWAL"
print("My name is:", name)

#Q2. Write a code to find the length of the string "Hello World"
text = "Hello World"
length = len(text)
print("The length of the string is:", length)

#Q3.  Write a code to slice the first 3 characters from the string "Python Programming"
text = "Python Programming"
sliced_text = text[:3]
print("The sliced string is:", sliced_text)

#Q4.  Write a code to convert the string "hello" to uppercase
text = "hello"
uppercase_text = text.upper()
print("The uppercase string is:", uppercase_text)

#Q5.Write a code to replace the word "apple" with "orange" in the string "I like apple"
text = "I like apple"
updated_text = text.replace("apple", "orange")
print("The updated string is:", updated_text)

#Q6.  Write a code to create a list with numbers 1 to 5 and print it
numbers = [1, 2, 3, 4, 5]
print("The list is:", numbers)

#Q7.  Write a code to append the number 10 to the list [1, 2, 3, 4]
numbers = [1, 2, 3, 4]
numbers.append(10)
print("The updated list is:", numbers)

#Q8. Write a code to remove the number 3 from the list [1, 2, 3, 4, 5]
numbers = [1, 2, 3, 4, 5]
numbers.remove(3)
print("The updated list is:", numbers)

#Q9.  Write a code to access the second element in the list ['a', 'b', 'c', 'd']
letters = ['a', 'b', 'c', 'd']
second_element = letters[1]
print("The second element is:", second_element)

#Q10. Write a code to reverse the list [10, 20, 30, 40, 50].
numbers = [10, 20, 30, 40, 50]
reversed_numbers = numbers[::-1]
print("The reversed list is:", reversed_numbers)

#Q11.  Write a code to create a tuple with the elements 100, 200, 300 and print it.
my_tuple = (100, 200, 300)
print("The tuple is:", my_tuple)

#Q12.  Write a code to access the second-to-last element of the tuple ('red', 'green', 'blue', 'yellow').
my_tuple = ('red', 'green', 'blue', 'yellow')
second_to_last = my_tuple[-2]
print("The second-to-last element is:", second_to_last)

#Q13. Write a code to find the minimum number in the tuple (10, 20, 5, 15).
my_tuple = (10, 20, 5, 15)
min_number = min(my_tuple)
print("The minimum number is:", min_number)

#Q14.  Write a code to find the index of the element "cat" in the tuple ('dog', 'cat', 'rabbit')
my_tuple = ('dog', 'cat', 'rabbit')
index_of_cat = my_tuple.index('cat')
print("The index of 'cat' is:", index_of_cat)

#Q15. Write a code to create a tuple containing three different fruits and check if "kiwi" is in it.
fruits = ('apple', 'banana', 'orange')
is_kiwi_present = 'kiwi' in fruits
print("Is 'kiwi' in the tuple?", is_kiwi_present)

#Q16.  Write a code to create a set with the elements 'a', 'b', 'c' and print it
my_set = {'a', 'b', 'c'}
print("The set is:", my_set)

#Q17.  Write a code to clear all elements from the set {1, 2, 3, 4, 5}.
my_set = {1, 2, 3, 4, 5}
my_set.clear()
print("The set after clearing all elements:", my_set)

#Q18. . Write a code to remove the element 4 from the set {1, 2, 3, 4}
my_set = {1, 2, 3, 4}
my_set.remove(4)
print("The set after removing 4:", my_set)

#Q19. Write a code to find the union of two sets {1, 2, 3} and {3, 4, 5}.
set1 = {1, 2, 3}
set2 = {3, 4, 5}
union_set = set1 | set2  # Using the '|' operator to find the union
# Alternatively, you can use set1.union(set2)
print("The union of the sets is:", union_set)

#Q20. Write a code to find the intersection of two sets {1, 2, 3} and {2, 3, 4}
set1 = {1, 2, 3}
set2 = {2, 3, 4}
intersection_set = set1 & set2  # Using the '&' operator to find the intersection
# Alternatively, you can use set1.intersection(set2)
print("The intersection of the sets is:", intersection_set)

#Q21.  Write a code to create a dictionary with the keys "name", "age", and "city", and print it.
my_dict = {
    "name": "POOJA",
    "age": 20,
    "city": "REWARI"
}

print("The dictionary is:", my_dict)

#Q22.  Write a code to add a new key-value pair "country": "USA" to the dictionary {'name': 'John', 'age': 25}.
person = {'name': 'John', 'age': 25}
person['country'] = 'USA'
print("Updated dictionary:", person)

#Q23. Write a code to access the value associated with the key "name" in the dictionary {'name': 'Alice', 'age': 30}.
person = {'name': 'Alice', 'age': 30}
name_value = person['name']
print("The value associated with 'name' is:", name_value)

#Q24. Write a code to remove the key "age" from the dictionary {'name': 'Bob', 'age': 22, 'city': 'New York'}.
person = {'name': 'Bob', 'age': 22, 'city': 'New York'}
person.pop('age')
print("Updated dictionary:", person)

#Q25.  Write a code to check if the key "city" exists in the dictionary {'name': 'Alice', 'city': 'Paris'}.
person = {'name': 'Alice', 'city': 'Paris'}

if 'city' in person:
    print("The key 'city' exists in the dictionary.")
else:
    print("The key 'city' does not exist in the dictionary.")

#Q26.  Write a code to create a list, a tuple, and a dictionary, and print them all.
# Creating a list
my_list = [1, 2, 3, 4, 5]
# Creating a tuple
my_tuple = ('apple', 'banana', 'cherry')
# Creating a dictionary
my_dict = {'name': 'Alice', 'age': 30, 'city': 'London'}
# Printing all of them
print("List:", my_list)
print("Tuple:", my_tuple)
print("Dictionary:", my_dict)

#Q27. Write a code to create a list of 5 random numbers between 1 and 100, sort it in ascending order, and print the result.(replaced)
import random

# Generate a list of 5 random numbers between 1 and 100
random_numbers = random.sample(range(1, 101), 5)

# Sort the list in ascending order
random_numbers.sort()

# Print the sorted list
print("Sorted random numbers:", random_numbers)

#Q28. Write a code to create a list with strings and print the element at the third index
# Create a list with strings
words = ["apple", "banana", "cherry", "date", "elderberry"]

# Print the element at the third index (which is the 4th element)
print("The element at index 3 is:", words[3])

#Q29.  Write a code to combine two dictionaries into one and print the result.
# Define two dictionaries
dict1 = {'name': 'Alice', 'age': 25}
dict2 = {'city': 'Paris', 'country': 'France'}

# Combine the dictionaries
combined_dict = {**dict1, **dict2}

# Print the result
print("Combined dictionary:", combined_dict)

#Q30. Write a code to convert a list of strings into a set
# Create a list of strings
string_list = ['apple', 'banana', 'cherry', 'apple']

# Convert the list into a set
string_set = set(string_list)

# Print the set
print("Set of strings:", string_set)

